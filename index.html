<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Every Badge</title>
    <style>
        .edge{
            stroke: none;
            fill:  #E24D2B;
            filter: url(#dropshadow);
            stroke-linejoin: round;
        }
        .inner-ring{
            fill: white;
        }
        .textured{
            fill: url(#stripey);
        }
        .stitches{
            fill: none;
            stroke: #EEBDA6;
            stroke-width: 5;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 20,20;
        }
        .hole{
            stroke: none;
            fill: white;
            filter: url(#innershadow);
        }
    </style>
</head>

<body id="home">

	<h1>Every Badge</h1>
    <svg id="svg" width="100%" height="100%" viewBox="-300 -300 600 600">
        <defs>
            <filter id="dropshadow" height="130%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <!-- stdDeviation is how much to blur -->
              <feOffset dx="2" dy="2" result="offsetblur"/> <!-- how much to offset -->
              <feMerge>
                <feMergeNode/> <!-- this contains the offset blurred image -->
                <feMergeNode in="SourceGraphic"/> <!-- this contains the element that the filter is applied to -->
              </feMerge>
            </filter>
            <filter id="innershadow" height="130%">
                <feOffset dx="5" dy="5" /><!-- Shadow Offset -->
                <feGaussianBlur stdDeviation="3" result="offset-blur" /> <!-- Shadow Blur -->
                <feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse" /> <!--Invert the drop shadow to create an inner shadow -->
                <feFlood flood-color="black" flood-opacity="0.75" result="color" /> <!-- Color & opacity -->
                <feComposite operator="in" in="color" in2="inverse" result="shadow" /> <!-- Clip color inside shadow -->
                <feComposite operator="over" in="shadow" in2="SourceGraphic" /> <!-- Put shadow over original object -->
            </filter>
            <linearGradient id="stripey" x1="0" y1="5" x2="5" y2="0" gradientUnits="userSpaceOnUse" spreadMethod="repeat">
                <stop offset="0%" style="stop-color: #EE6629" />
                <stop offset="50%" style="stop-color: #EE6629" />
                <stop offset="51%" style="stop-color: #F1743E" />
                <stop offset="100%" style="stop-color: #F1743E" />
            </linearGradient>
        </defs>
        <g id="svg" transform="translate(300,300)"></g>
    </svg>

    <script>
        var SVG_NS = 'http://www.w3.org/2000/svg';
        var svg = document.getElementById('svg');
        function range(num){
            var r = [];
            for (var i = 0; i < num; i++){
                r.push(i);
            }
            return r;
        }
        function getPointAtDistance( p1, p2, dis ){
           //get vector
           var x3 = p2[0] - p1[0];
           var y3 = p2[1] - p1[1];

           //normalize vector
           var length = Math.sqrt( x3 * x3 + y3 * y3 );
           x3 /= length;
           y3 /= length;

           //scale vector
           x3 *= dis;
           y3 *= dis;

           //add vector back onto initial point and return
           return [p1[0] + x3, p1[1] + y3];

        }
        function dot(pt){
            var c = document.createElementNS(SVG_NS, 'circle');
            c.setAttribute('cx', pt[0]);
            c.setAttribute('cy', pt[1]);
            c.setAttribute('r', 10);
            svg.appendChild(c);
            return c;
        }
        function roundedPolygon(sides, radius, cornerRadius, klass){
            var angle = (Math.PI * 2) / sides;
            var corners = range(sides).map(function(idx){
                return [Math.cos(idx * angle) * radius, Math.sin(idx * angle) * radius];
            });
            // calculate midpoints
            var pt = getPointAtDistance(corners[0], corners[sides - 1], cornerRadius);
            var m = ['M' + pt[0] + ',' + pt[1]];
            corners.forEach(function(corner, idx){
                var next = corners[(idx + 1) % sides];
                var p1 = getPointAtDistance(corner, next, cornerRadius);
                var p2 = getPointAtDistance(next, corner, cornerRadius);
                m.push('Q' + corner[0] + ',' + corner[1] + ' ' + p1[0] + ',' + p1[1]);
                m.push('L' + p2[0] + ',' + p2[1]);
            })
            m.push('z');
            var poly = document.createElementNS(SVG_NS, 'path');
            poly.setAttribute('class', klass);
            poly.setAttribute('d', m.join(' '));
            return poly;
        }
        svg.appendChild(roundedPolygon(6, 270, 20, 'edge'));
        svg.appendChild(roundedPolygon(6, 250, 20, 'inner-ring'));
        svg.appendChild(roundedPolygon(6, 240, 20, 'textured'));
        svg.appendChild(roundedPolygon(6, 220, 20, 'stitches'));
        var circle = document.createElementNS(SVG_NS, 'circle');
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);
        circle.setAttribute('r', 80);
        circle.setAttribute('class', 'hole');
        svg.appendChild(circle);
    </script>

</body>
</html>
